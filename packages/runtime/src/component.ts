import type { ComponentInstance, HookEffect, Props } from '@polyx/core';
import { setCurrentInstance } from './hooks-internals.js';
import { depsChanged } from './hooks.js';
import { reconcileChildren, reconcileNonKeyed } from './reconcile.js';
import type { KeyedItem } from './reconcile.js';
import { isTransition, isIdle, scheduleTransition, scheduleIdle } from './scheduler.js';
import { getHMR } from './hmr.js';
import { getDevTools } from './devtools.js';
import { isSuspensePromise, findSuspenseBoundary } from './suspense.js';
import { acquireNode, releaseNode } from './pool.js';

export type RenderFn = (instance: any) => void;

const templateCache = new Map<string, HTMLTemplateElement>();

export function createTemplate(html: string): HTMLTemplateElement {
  if (templateCache.has(html)) return templateCache.get(html)!;
  const template = document.createElement('template');
  template.innerHTML = html;
  templateCache.set(html, template);
  return template;
}

export function clearTemplateCache(): void {
  templateCache.clear();
}

export abstract class PolyXElement extends HTMLElement {
  protected _instance: ComponentInstance;
  protected _isConnected = false;
  protected _hasMounted = false;
  protected _pendingUpdate = false;

  // State storage
  protected _state: Record<string, any> = {};
  // Props storage (received from parent)
  protected _props: Props = {};
  // Dynamic node markers cache
  protected _valueMarkers: (Node | Comment)[] = [];
  protected _valueCache: any[] = [];
  // Unified element references indexed by marker idx
  protected _elements: HTMLElement[] = [];
  // Legacy maps kept for backward compat during transition
  protected _dynamicElements: Map<string, HTMLElement[]> = new Map();
  protected _childElements: Map<number, HTMLElement> = new Map();
  // Array children tracking for list reconciliation
  private _arrayChildren: Map<number, Node[]> = new Map();
  private _arrayValues: Map<number, any[]> = new Map();
  // Keyed list reconciliation tracking
  private _keyedChildren: Map<number, KeyedItem[]> = new Map();
  // Targeted effects pending from _renderState_* methods
  private _pendingTargetedEffects: { hookIndex: number; isLayout: boolean }[] = [];

  constructor() {
    super();
    this._instance = {
      hooks: [],
      hookIndex: 0,
      effects: [],
      layoutEffects: [],
      element: this,
      render: () => this._updateDynamicParts(),
    };
  }

  static get observedAttributes(): string[] {
    return [];
  }

  attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {
    if (oldValue !== newValue) {
      const stateKey = this._attrToStateKey(name);
      if (this._state[stateKey] !== newValue) {
        this._updateState(stateKey, newValue);
      }
      // Also sync to props for attribute-based prop setting
      if (this._props[stateKey] !== newValue) {
        this._props[stateKey] = newValue;
      }
    }
  }

  private _attrToStateKey(attr: string) {
    return attr.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  }

  connectedCallback() {
    this._isConnected = true;
    // Restore props set by parent before this element was upgraded
    if ((this as any).__pendingPolyXProps) {
      Object.assign(this._props, (this as any).__pendingPolyXProps);
      delete (this as any).__pendingPolyXProps;
    }
    getHMR()?.trackInstance(this.tagName.toLowerCase(), this);
    getDevTools()?._onMount(this);
    if (!this._hasMounted) {
      this._mount();
    } else {
      this._updateDynamicParts();
    }
  }

  disconnectedCallback() {
    this._isConnected = false;
    this._cleanup();
    getDevTools()?._onUnmount(this);
  }

  protected abstract _render(): void;

  // Set a prop from outside (parent component)
  _setProp(name: string, value: any) {
    if (this._props[name] !== value) {
      this._props[name] = value;
      if (this._isConnected && this._hasMounted) {
        this._scheduleUpdate();
      }
    }
  }

  // Batch set multiple props
  _setProps(props: Props) {
    let changed = false;
    for (const key in props) {
      if (this._props[key] !== props[key]) {
        this._props[key] = props[key];
        changed = true;
      }
    }
    if (changed && this._isConnected && this._hasMounted) {
      this._scheduleUpdate();
    }
  }

  // State update with fine-grained reactivity
  protected _updateState(key: string, value: any) {
    this._state[key] = value;
    if (this._isConnected) {
      // Check for targeted state handler (generated by compiler for fine-grained reactivity)
      const handler = (this as any)[`_renderState_${key}`];
      if (handler && !this._pendingUpdate) {
        this._scheduleTargetedUpdate(key);
      } else {
        this._scheduleUpdate();
      }
    }
  }

  // Re-execute useMemo/useCallback at a specific hook index (deps-checked)
  protected _execMemo(hookIndex: number, factory: () => any, deps: any[]): any {
    const hook = this._instance.hooks[hookIndex];
    if (hook && !depsChanged(hook.deps, deps)) {
      return hook.value;
    }
    const value = factory();
    this._instance.hooks[hookIndex] = { value, deps };
    return value;
  }

  // Read a hook's cached value without re-execution
  protected _readHook(hookIndex: number): any {
    const hook = this._instance.hooks[hookIndex];
    if (hook && typeof hook === 'object') {
      // useMemo/useCallback: { value, deps }
      if ('deps' in hook && 'value' in hook) return hook.value;
      // useContext: { provider, unsubscribe, selector?, selectedValue?, ... }
      if ('provider' in hook) {
        if (hook.selector && hook.provider) {
          return hook.selectedValue;
        }
        return hook.provider ? hook.provider.value : undefined;
      }
    }
    // useRef: { current: ... } — return the object itself
    // Or primitive hooks
    return hook;
  }

  // Queue an effect for targeted execution (deps-checked)
  protected _queueEffect(hookIndex: number, callback: Function, deps: any[] | undefined): void {
    const prevHook = this._instance.hooks[hookIndex];
    if (prevHook && deps !== undefined && !depsChanged(prevHook.deps, deps)) {
      return; // deps unchanged, skip
    }
    this._instance.hooks[hookIndex] = {
      callback,
      deps,
      cleanup: prevHook?.cleanup,
    };
    this._pendingTargetedEffects.push({ hookIndex, isLayout: false });
  }

  // Queue a layout effect for targeted execution (deps-checked)
  protected _queueLayoutEffect(hookIndex: number, callback: Function, deps: any[] | undefined): void {
    const prevHook = this._instance.hooks[hookIndex];
    if (prevHook && deps !== undefined && !depsChanged(prevHook.deps, deps)) {
      return;
    }
    this._instance.hooks[hookIndex] = {
      callback,
      deps,
      cleanup: prevHook?.cleanup,
    };
    this._pendingTargetedEffects.push({ hookIndex, isLayout: true });
  }

  // Flush targeted effects: run layout effects synchronously, schedule regular effects
  protected _flushTargetedEffects(): void {
    const effects = this._pendingTargetedEffects;
    if (effects.length === 0) return;
    this._pendingTargetedEffects = [];

    // Run layout effects synchronously
    for (const eff of effects) {
      if (eff.isLayout) {
        const hook = this._instance.hooks[eff.hookIndex];
        if (hook.cleanup) hook.cleanup();
        const cleanup = hook.callback();
        hook.cleanup = typeof cleanup === 'function' ? cleanup : undefined;
      }
    }

    // Queue regular effects via microtask
    const regularEffects = effects.filter(e => !e.isLayout);
    if (regularEffects.length > 0) {
      queueMicrotask(() => {
        if (!this._isConnected) return;
        for (const eff of regularEffects) {
          const hook = this._instance.hooks[eff.hookIndex];
          if (hook.cleanup) hook.cleanup();
          const cleanup = hook.callback();
          hook.cleanup = typeof cleanup === 'function' ? cleanup : undefined;
        }
      });
    }
  }

  // Track pending targeted state keys for batching
  private _pendingStateKeys: Set<string> | null = null;

  private _scheduleTargetedUpdate(key: string) {
    if (this._pendingUpdate) return; // Full update already pending
    if (!this._pendingStateKeys) {
      this._pendingStateKeys = new Set();
      queueMicrotask(() => {
        if (!this._isConnected) {
          this._pendingStateKeys = null;
          return;
        }
        const keys = this._pendingStateKeys;
        this._pendingStateKeys = null;
        if (keys && keys.size > 0) {
          for (const k of keys) {
            if (this._pendingUpdate) break; // full update supersedes targeted
            const h = (this as any)[`_renderState_${k}`];
            if (h) h.call(this);
          }
        }
      });
    }
    this._pendingStateKeys.add(key);
  }

  private _scheduleUpdate() {
    if (this._pendingUpdate) return;
    this._pendingUpdate = true;
    // Cancel any pending targeted updates — full update supersedes them
    this._pendingStateKeys = null;

    if (isIdle()) {
      // Lowest priority: defer to requestIdleCallback
      scheduleIdle(() => {
        this._pendingUpdate = false;
        if (this._isConnected) {
          this._updateDynamicParts();
        }
      });
    } else if (isTransition()) {
      // Low priority: defer to requestAnimationFrame
      scheduleTransition(() => {
        this._pendingUpdate = false;
        if (this._isConnected) {
          this._updateDynamicParts();
        }
      });
    } else {
      // High priority: immediate microtask (default behavior)
      queueMicrotask(() => {
        this._pendingUpdate = false;
        if (this._isConnected) {
          this._updateDynamicParts();
        }
      });
    }
  }

  protected _updateDynamicParts() {
    if (!this._isConnected) return;

    const devTools = getDevTools();
    const startTime = devTools ? performance.now() : 0;

    setCurrentInstance(this._instance);
    this._instance.hookIndex = 0;
    try {
      this._render();

      this._runLayoutEffects();
      if (this._instance.effects.length > 0) {
        queueMicrotask(() => this._runEffects());
      }
    } catch (thrown) {
      if (isSuspensePromise(thrown)) {
        const boundary = findSuspenseBoundary(this);
        if (boundary) {
          boundary._handleSuspend(thrown as Promise<any>, this);
        } else {
          console.error('No <Suspense> boundary found for', this.tagName);
        }
      } else {
        console.error('Update error:', thrown);
      }
    } finally {
      setCurrentInstance(null);
      if (devTools) {
        devTools._onUpdate(this, performance.now() - startTime);
      }
    }
  }

  protected _setDynamicValue(index: number, value: any) {
    // In events-only mode (resumable hydration), skip all DOM updates
    if ((this as any).__polyx_events_only) return;

    // Skip Arrays from cache check — they need reconciliation every time
    if (!Array.isArray(value) && this._valueCache[index] === value) {
      return; // Reference equality: skip unchanged primitives and objects
    }

    const current = this._valueMarkers[index];
    this._valueCache[index] = value;

    if (Array.isArray(value)) {
      // Array list rendering with reconciliation
      const marker = current;
      const oldNodes = this._arrayChildren.get(index) || [];
      const oldValues = this._arrayValues.get(index) || [];
      const newNodes = reconcileNonKeyed(
        marker.parentNode || this,
        marker,
        oldNodes,
        value,
        oldValues,
        this._createNodeFromValue.bind(this)
      );
      this._arrayChildren.set(index, newNodes);
      this._arrayValues.set(index, [...value]);
      return; // Don't replace the marker itself
    }

    let newNode: Node;

    if (value === false || value === null || value === undefined) {
      newNode = document.createComment('falsy');
    } else if (value instanceof DocumentFragment) {
      const wrapper = document.createElement('span');
      wrapper.style.display = 'contents';
      wrapper.appendChild(value);
      newNode = wrapper;
    } else if (value instanceof Node) {
      newNode = value;
    } else if (typeof value === 'string' && value.startsWith('polyx-')) {
      const childEl = document.createElement(value);
      this._childElements.set(index, childEl);
      newNode = childEl;
    } else {
      // Primitive text: fast path — update textContent directly if current is TextNode
      const strVal = String(value);
      if (current && current.nodeType === Node.TEXT_NODE) {
        if (current.textContent !== strVal) {
          current.textContent = strVal;
        }
        return;
      }
      newNode = document.createTextNode(strVal);
    }

    if (current && current !== newNode) {
      if (current.parentNode) {
        current.parentNode.replaceChild(newNode, current);
      }
      // Release the old node to the recycling pool
      releaseNode(current);
      this._valueMarkers[index] = newNode;
    }
  }

  // Set a prop on a child component element at a given marker index
  protected _setDynamicProp(index: number, propName: string, value: any) {
    // In events-only mode (resumable hydration), skip prop updates
    if ((this as any).__polyx_events_only) return;

    const childEl = this._elements[index] || this._childElements.get(index);
    if (!childEl) return;
    if ('_setProp' in childEl) {
      (childEl as any)._setProp(propName, value);
    } else {
      if (!(childEl as any).__pendingPolyXProps) {
        (childEl as any).__pendingPolyXProps = {};
      }
      (childEl as any).__pendingPolyXProps[propName] = value;
    }
  }

  // Create a DOM node from a value (used by list reconciliation)
  private _createNodeFromValue(value: any): Node {
    if (value === false || value === null || value === undefined) {
      return document.createComment('falsy');
    } else if (value instanceof Node) {
      return value;
    } else if (typeof value === 'string' && value.startsWith('polyx-')) {
      return acquireNode(value) as Node || document.createElement(value);
    } else {
      return document.createTextNode(String(value));
    }
  }

  // Create or reuse a child component element with props
  protected _createChild(tagName: string, props?: Record<string, any>): HTMLElement {
    const el = (acquireNode(tagName) as HTMLElement) || document.createElement(tagName);
    if (props) {
      if ('_setProps' in el) {
        (el as any)._setProps(props);
      } else {
        // Element not yet upgraded — store pending props for connectedCallback
        (el as any).__pendingPolyXProps = props;
      }
    }
    return el;
  }

  // Keyed list reconciliation: reuse existing elements by key, minimal DOM moves via LIS
  protected _setKeyedList(
    index: number,
    descriptors: { key: string | number; tag: string; props: Record<string, any> }[]
  ): void {
    const marker = this._valueMarkers[index];
    if (!marker) return;

    const oldKeyed = this._keyedChildren.get(index) || [];
    const oldKeyMap = new Map<string | number, KeyedItem>();
    for (const item of oldKeyed) oldKeyMap.set(item.key, item);

    const newKeyed: KeyedItem[] = descriptors.map(desc => {
      const existing = oldKeyMap.get(desc.key);
      if (existing) {
        // REUSE: update props only (no DOM recreation)
        if ('_setProps' in (existing.node as any)) {
          (existing.node as any)._setProps(desc.props);
        }
        oldKeyMap.delete(desc.key);
        return { key: desc.key, node: existing.node };
      } else {
        // CREATE: new element
        return { key: desc.key, node: this._createChild(desc.tag, desc.props) };
      }
    });

    // Remove old items not in new list and release to pool
    for (const [, item] of oldKeyMap) {
      item.node.parentNode?.removeChild(item.node);
      releaseNode(item.node);
    }

    // LIS-based minimal DOM moves
    reconcileChildren(marker.parentNode!, marker, oldKeyed, newKeyed);
    this._keyedChildren.set(index, newKeyed);
  }

  protected _setDynamicAttribute(index: number, attrName: string, value: any) {
    // In events-only mode (resumable hydration), skip all DOM updates
    if ((this as any).__polyx_events_only) return;

    const el = this._elements[index];
    if (el) {
      if (value === false || value === null || value === undefined) {
        el.removeAttribute(attrName);
      } else {
        const strVal = value === true ? '' : String(value);
        if (el.getAttribute(attrName) !== strVal) {
          el.setAttribute(attrName, strVal);
        }
      }
      return;
    }
    // Fallback to legacy map for backward compat
    const key = `attr-${attrName}-${index}`;
    const elements = this._dynamicElements.get(key);
    if (!elements) return;
    elements.forEach(legacyEl => {
      if (value === false || value === null || value === undefined) {
        legacyEl.removeAttribute(attrName);
      } else {
        const strVal = value === true ? '' : String(value);
        if (legacyEl.getAttribute(attrName) !== strVal) {
          legacyEl.setAttribute(attrName, strVal);
        }
      }
    });
  }

  protected _setDynamicEvent(index: number, eventName: string, handler: Function) {
    const el = this._elements[index];
    if (el) {
      const storageKey = `__polyx_evt_${eventName}`;
      const wrapperKey = `__polyx_wrap_${eventName}`;
      (el as any)[storageKey] = handler;
      if (!(el as any)[wrapperKey]) {
        const wrapper: EventListener = (event: Event) => {
          const currentHandler = (el as any)[storageKey];
          if (currentHandler) currentHandler(event);
        };
        (el as any)[wrapperKey] = wrapper;
        el.addEventListener(eventName, wrapper);
      }
      return;
    }
    // Fallback to legacy map
    const key = `event-${eventName}-${index}`;
    const elements = this._dynamicElements.get(key);
    if (!elements) return;
    elements.forEach(legacyEl => {
      const storageKey = `__polyx_evt_${eventName}`;
      const wrapperKey = `__polyx_wrap_${eventName}`;
      (legacyEl as any)[storageKey] = handler;
      if (!(legacyEl as any)[wrapperKey]) {
        const wrapper: EventListener = (event: Event) => {
          const currentHandler = (legacyEl as any)[storageKey];
          if (currentHandler) currentHandler(event);
        };
        (legacyEl as any)[wrapperKey] = wrapper;
        legacyEl.addEventListener(eventName, wrapper);
      }
    });
  }

  // Apply spread attributes to an element
  protected _setDynamicSpread(index: number, props: Record<string, any>) {
    const el = this._elements[index];
    if (el) {
      this._applySpreadToElement(el, props);
      return;
    }
    // Fallback to legacy map
    const key = `spread-${index}`;
    const elements = this._dynamicElements.get(key);
    if (!elements) return;
    elements.forEach(legacyEl => this._applySpreadToElement(legacyEl, props));
  }

  private _applySpreadToElement(el: HTMLElement, props: Record<string, any>) {
    for (const [name, value] of Object.entries(props)) {
      if (name === 'key' || name === 'ref' || name === 'children') continue;

      if (name === 'className' || name === 'class') {
        el.setAttribute('class', String(value));
      } else if (name.startsWith('on') && typeof value === 'function') {
        const eventName = name.slice(2).toLowerCase();
        const storageKey = `__polyx_evt_${eventName}`;
        const wrapperKey = `__polyx_wrap_${eventName}`;
        (el as any)[storageKey] = value;
        if (!(el as any)[wrapperKey]) {
          const wrapper: EventListener = (event: Event) => {
            const currentHandler = (el as any)[storageKey];
            if (currentHandler) currentHandler(event);
          };
          (el as any)[wrapperKey] = wrapper;
          el.addEventListener(eventName, wrapper);
        }
      } else if (value === false || value === null || value === undefined) {
        el.removeAttribute(name);
      } else if (value === true) {
        el.setAttribute(name, '');
      } else {
        el.setAttribute(name, String(value));
      }
    }
  }

  private _mount() {
    const template = (this.constructor as any).template;
    if (!template) return;

    const isHydrating = (this as any).__polyx_hydrating === true;
    const isResuming = (this as any).__polyx_resume === true;

    // Save children passed from parent (light DOM content before mount)
    if (!isHydrating && this.childNodes.length > 0 && !this._props.children) {
      const fragment = document.createDocumentFragment();
      while (this.firstChild) {
        fragment.appendChild(this.firstChild);
      }
      this._props.children = fragment;
    }

    if (isHydrating) {
      // Hydration: reuse existing DOM, just find markers
      this._hydrateExistingDOM();
    } else {
      // Normal mount: clone template and insert
      const content = template.content.cloneNode(true) as DocumentFragment;

      content.querySelectorAll('span[data-dyn]').forEach(span => {
        const idx = parseInt(span.getAttribute('data-dyn')!);
        const marker = document.createComment(`dyn-${idx}`);
        span.replaceWith(marker);
        this._valueMarkers[idx] = marker;
      });

      this._scanDynamicElements(content);

      this.innerHTML = '';
      this.appendChild(content);
    }

    this._hasMounted = true;

    if (isResuming) {
      // Resumable hydration: restore state, attach events only, schedule effects
      const serializedState = (this as any).__polyx_serialized_state;
      if (serializedState) {
        Object.assign(this._state, serializedState);
        delete (this as any).__polyx_serialized_state;
      }
      this._attachEventsOnly();
    } else {
      this._updateDynamicParts();
    }
  }

  /**
   * Attach only event handlers without touching the DOM.
   * Used during resumable hydration to skip re-rendering while still
   * binding event handlers and scheduling effects.
   */
  private _attachEventsOnly() {
    if (!this._isConnected) return;

    // Set events-only flag — _setDynamicValue and _setDynamicAttribute become no-ops
    (this as any).__polyx_events_only = true;

    setCurrentInstance(this._instance);
    this._instance.hookIndex = 0;
    try {
      this._render();

      // Schedule effects normally (they need to run for side effects)
      this._runLayoutEffects();
      if (this._instance.effects.length > 0) {
        queueMicrotask(() => this._runEffects());
      }
    } catch (thrown) {
      if (isSuspensePromise(thrown)) {
        const boundary = findSuspenseBoundary(this);
        if (boundary) {
          boundary._handleSuspend(thrown as Promise<any>, this);
        }
      } else {
        console.error('Resume hydration error:', thrown);
      }
    } finally {
      setCurrentInstance(null);
      (this as any).__polyx_events_only = false;
    }
  }

  // Scan a DOM tree for dynamic element markers
  private _scanDynamicElements(root: DocumentFragment | HTMLElement) {
    // Unified scan: data-px-el markers
    root.querySelectorAll('[data-px-el]').forEach(el => {
      const element = el as HTMLElement;
      const idx = parseInt(element.getAttribute('data-px-el')!);
      this._elements[idx] = element;
      // Also populate legacy maps for child elements (component tags)
      this._childElements.set(idx, element);
    });

    // Legacy scan for backward compat (data-attr-*, data-event-*, data-spread, data-child-idx)
    root.querySelectorAll('*').forEach(el => {
      const element = el as HTMLElement;
      [...element.attributes].forEach(attr => {
        if (attr.name === 'data-child-idx') {
          const idx = parseInt(attr.value);
          this._childElements.set(idx, element);
          this._elements[idx] = element;
        } else if (attr.name.startsWith('data-attr-')) {
          const attrName = attr.name.slice(10);
          const key = `attr-${attrName}-${attr.value}`;
          if (!this._dynamicElements.has(key)) this._dynamicElements.set(key, []);
          this._dynamicElements.get(key)!.push(element);
        } else if (attr.name === 'data-spread') {
          const key = `spread-${attr.value}`;
          if (!this._dynamicElements.has(key)) this._dynamicElements.set(key, []);
          this._dynamicElements.get(key)!.push(element);
        } else if (attr.name.startsWith('data-event-')) {
          const name = attr.name.slice(11);
          const key = `event-${name}-${attr.value}`;
          if (!this._dynamicElements.has(key)) this._dynamicElements.set(key, []);
          this._dynamicElements.get(key)!.push(element);
        }
      });
    });
  }

  // Hydration: walk existing DOM to find markers and dynamic elements
  private _hydrateExistingDOM() {
    // Find comment nodes (dyn markers) in existing DOM
    const walker = document.createTreeWalker(this, NodeFilter.SHOW_COMMENT);
    let comment: Comment | null;
    while ((comment = walker.nextNode() as Comment | null)) {
      const match = comment.textContent?.match(/^dyn-(\d+)$/);
      if (match) {
        const idx = parseInt(match[1]);
        this._valueMarkers[idx] = comment;
      }
    }

    // Scan for unified and legacy dynamic elements in existing DOM
    this._scanDynamicElements(this as any);
  }

  private _runEffects(): void {
    if (!this._isConnected) return;

    this._instance.effects.forEach(effect => {
      if (effect.cleanup) effect.cleanup();
      const cleanup = effect.callback();
      if (cleanup) effect.cleanup = cleanup;
    });
    this._instance.effects = [];
  }

  private _runLayoutEffects(): void {
    this._instance.layoutEffects.forEach(effect => {
      if (effect.cleanup) effect.cleanup();
      const cleanup = effect.callback();
      if (cleanup) effect.cleanup = cleanup;
    });
    this._instance.layoutEffects = [];
  }

  private _cleanup() {
    this._instance.effects.forEach(e => e.cleanup?.());
    this._instance.layoutEffects.forEach(e => e.cleanup?.());

    this._instance.hooks.forEach(hook => {
      if (hook && typeof hook === 'object' && 'cleanup' in hook && typeof hook.cleanup === 'function') {
        hook.cleanup();
        hook.cleanup = undefined;
      }
    });

    // Cleanup events from unified _elements
    this._elements.forEach(el => {
      if (!el) return;
      [...Object.keys(el)].forEach((key: string) => {
        if (key.startsWith('__polyx_wrap_')) {
          const eventName = key.slice(13);
          const wrapper = (el as any)[key];
          if (wrapper) {
            el.removeEventListener(eventName, wrapper);
            (el as any)[key] = null;
          }
          (el as any)[`__polyx_evt_${eventName}`] = null;
        }
      });
    });

    // Legacy cleanup
    this._dynamicElements.forEach((elements, key) => {
      if (key.startsWith('event-')) {
        const eventName = key.split('-')[1];
        elements.forEach(el => {
          const wrapperKey = `__polyx_wrap_${eventName}`;
          const storageKey = `__polyx_evt_${eventName}`;
          if ((el as any)[wrapperKey]) {
            el.removeEventListener(eventName, (el as any)[wrapperKey]);
            (el as any)[wrapperKey] = null;
          }
          (el as any)[storageKey] = null;
        });
      }
    });
  }

  static createTemplate(html: string) {
    return createTemplate(html);
  }
}

export function defineComponent(tagName: string, renderFn: (instance: PolyXElement) => void): void {
  class CustomElement extends PolyXElement {
    protected _render(): void {
      renderFn(this);
    }
  }

  customElements.define(tagName, CustomElement);
  getHMR()?.register(tagName, CustomElement);
}
